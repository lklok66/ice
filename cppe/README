Introduction
============

This archive contains the Ice-E source code for the C++ language
mapping (in the cppe directory) as well as the C++ source code for the
Slice-to-Embedded-C++ translators (in the cpp directory).

Ice-E is a compact subset of Ice designed for embedded environments
while retaining many of the features that have made Ice such a
compelling alternative for distributed applications.


Comparing Ice-E and Ice
=======================

In order to reduce the size of the Ice-E run time, several Ice
features have been removed, and others are optional. The differences
are discussed in the sections below.


Concurrency Models
------------------

As in Ice, Ice-E supports only the thread pool concurrency model.
However, unlike Ice, Ice-E does not support the configuration of
per-adapter thread pools.


Transports
----------

Ice-E includes support for the TCP transport; UDP and SSL are not
supported. The built-in TCP transport can be replaced with one of your
own.


Servant Locators
----------------

Ice-E does not support servant locators. However, Ice-E does support
default servants. A default servant is a regular servant that you
implement and register with an object adapter. For each incoming
request, the object adapter first attempts to locate a servant in its
Active Servant Map (ASM). If no servant is found, the object adapter
dispatches the request to a default servant. With this design, a
default servant is the object adapter's servant of last resort if no
match was found in the ASM.

The default servant API consists of the following operations in the
object adapter interface.

module Ice {
    interface ObjectAdapter {
        // ...

        void addDefaultServant(Object servant, string category);

        Object removeDefaultServant(string category);

        Object findDefaultServant(string category);

        // ...
    };
};

As you can see, the object adapter allows you to add, remove and find
default servants. Note that, when you register a default servant, you
must provide an argument for the category parameter. The value of the
category parameter controls which object identities the default
servant is responsible for: only object identities with a matching
category member trigger a dispatch to this default servant. An
incoming request for which no explicit entry exists in the ASM and
with a category for which no default servant is registered returns an
ObjectNotExistException to the client.

addDefaultServant has the following semantics:

 * You can register exactly one default servant for a specific
   category.  Attempts to call addDefaultServant for the same category
   more than once raise an AlreadyRegisteredException.

 * You can register different default servants for different
   categories, or you can register the same single default servant
   multiple times (each time for a different category). In the former
   case, the category is implicit in the default servant instance that
   is called by the Ice-E run time; in the latter case, the servant
   can find out which category the incoming request is for by
   examining the object identity member of the Current object that is
   passed to the dispatched operation.

 * It is legal to register a default servant for the empty category.
   Such a servant is used if a request comes in for which no entry
   exists in the ASM, and whose category does not match the category
   of any other registered default servant.

The removeDefaultServant operation allows you to remove the default
servant for a specific category. It returns the servant that was
removed. If no default servant is registered for the specified
category, removeDefaultServant throws a NotRegisteredException.

The findDefaultServant operation allows you to retrieve the default
servant for a specific category (including the empty category). If no
default servant is registered for the specified category,
findDefaultServant returns null.


Collocation Optimization
------------------------

Support for collocation optimization has been removed. Note that
Ice-E applications are still able to make invocations on collocated
servants, but those invocations are not optimized and therefore will
be marshaled and sent over the built-in transport.


Other Removed Features
----------------------

Ice-E has also eliminated the following features:

* Asynchronous dispatch (AMD)
* Streaming APIs
* Active connection management
* Protocol compression
* Ice::Application and Ice::Service classes
* Local interfaces
* StaticMutex


Optional Features
-----------------

A number of Ice-E features are optional and can be omitted during
compilation to further reduce the size of the Ice-E run time. See the
"Configuration" section below for more information.


Compatibility
-------------

Ice-E and Ice share the same C++ mapping and remain source-code
compatible, given the limitations described above. Furthermore,
since the two products also share the same protocol, a distributed
system can use any combination of Ice and Ice-E applications.


Customization
-------------

If the current features do not meet your requirements, ZeroC can
customize Ice-E for commercial users. Please contact us at
info@zeroc.com for more information.


Real-time Features
==================

Ice-E includes support for the real-time features described below.


Thread API
----------

Added a new start operation with an integer parameter representing the
new thread's initial priority. The priority value is system-dependent;
on POSIX systems the parameter must be a legal value for the
underlying SCHED_RR scheduler. Note that root privileges are required
when using SCHED_RR. Attempting to start a thread with an invalid
priority raises ThreadSyscallException.

Threads that are started without a priority use the system's default
priority, which is backward-compatible with prior Ice-E releases.


Mutex API
---------

Ice-E includes some real-time enhancements to the mutex API for POSIX
systems:

* MutexProtocol enumeration

  This enumeration specifies the underlying protocol used by a mutex.
  The enumerators are PrioNone and PrioInherit.

* Constructors

  The Mutex and RecMutex classes have new constructors that accept a
  MutexProtocol parameter.

  If a Mutex or RecMutex object is instantiated using the default
  constructor, it uses the mutex protocol returned by the function
  IceUtil::getDefaultMutexProtocol declared in MutexProtocol.h. On
  Linux, and possibly on other unsupported POSIX platforms, an
  application can "override" this function by defining its own version
  of IceUtil::getDefaultMutexProtocol.

  By default, this method returns the mutex protocol defined by the
  DEFAULT_MUTEX_PROTOCOL macro defined in the cppe/config/Make.rules
  file.

Timer API
---------

The IceUtil::Timer class has a constructor that accepts an integer
parameter representing the priority to use for the internal thread
created by the timer. The priority parameter has the same semantics as
for starting a thread (see Thread API above).


New Properties
--------------

* Ice.ThreadPriority

  The property sets the priority of Ice's internal threads to a native
  thread priority. On POSIX systems, the priority must be a legal
  value for the SCHED_RR scheduler. On Windows and Windows CE, the
  priority can be any of the valid system priorities. Regardless of
  platform, the value must be expressed as an integer.

  The value of this property is also used as the default priority for
  the threads in an Ice thread pool if not otherwise specified using
  one of the thread pool properties described below.

* Ice.ThreadPool.Server.ThreadPriority

  This property sets the priority for all threads in the server thread
  pool.

* Ice.ThreadPool.Client.ThreadPriority

  This property sets the priority for all threads in the client thread
  pool.


Tests
-----

Real-time tests need to run as super user on POSIX systems, therefore
allTests.py has been changed to only execute these tests when the user
is root on Linux.

There are two tests for real-time features:

* test/IceE/priority
* test/IceE/threadPoolPriority


Run-time Libraries
==================

In order to minimize the size of Ice-E applications, two versions of
the run-time library are provided:

* The "client" library is suitable for applications requiring only
  client-side functionality.

* The "server" library supports client- and server-side functionality.

A simple rule of thumb is to use the server library if your program
creates an object adapter, otherwise you can use the client library.

Users of the client library must define the preprocessor macro
ICEE_PURE_CLIENT when compiling an application and link with the
appropriate run-time library.


Configuration
=============

You may build the Ice-E run-time libraries with certain components
disabled in order to further reduce the size of your applications. The
default configuration enables all of the optional components, but you
can selectively disable them by editing the file config/Make.rules
(Linux) or config\Make.rules.mak (Windows) and modifying their
corresponding settings. The optional components are described below.
For more information on these features, please refer to the Ice
manual.

Before building Ice-E for the first time, or after any change to the
configuration settings in Make.rules or Make.rules.mak, you must
make the "configure" target as shown below:

On Linux:

  $ make configure

On Windows:

  > nmake /f Makefile.mak configure

The purpose of the "configure" target is to generate the header file
include/IceE/Features.h with preprocessor macros that correspond to
your settings in Make.rules or Make.rules.mak.


Router Support
--------------

If HAS_ROUTER is enabled, the Ice-E libraries will include support for
the Ice router facility. This component is necessary in order to use
Ice-E with the Glacier2 router.

Applications that use routers often also receive callbacks from remote
servers. These applications must use the server library, because the
client library does not provide support for callbacks.


Locator Support
---------------

If HAS_LOCATOR is enabled, the Ice-E libraries will include support
for the Ice locator facility. This component is necessary in order to
use indirect proxies in Ice-E.


Batch Messages Support
----------------------

If HAS_BATCH is enabled, the Ice-E client library will include support
for sending batch messages. This feature cannot be disabled in the
server library.


Wstring and String Converter Support
------------------------------------

If HAS_WSTRING is enabled, the Ice-E libraries will include support
for using wide strings as well as configuring custom string
converters.


Opaque Endpoint Support
-----------------------

The HAS_OPAQUE_ENDPOINTS setting determines whether the Ice run time
preserves proxy endpoints whose types are not recognized. This feature
is unnecessary in an environment in which all clients and servers use
Ice-E, since TCP is the only supported transport. When Ice-E programs
communicate with Ice programs, however, it is possible for an Ice-E
program to receive a proxy that contains unsupported endpoints, such
as SSL or UDP. Ice-E discards these endpoints when this feature is
disabled, but discarding the endpoints prevents an Ice-E program from
forwarding the proxy with its original endpoints intact. Enabling
opaque endpoints causes Ice-E to retain unknown endpoints in the proxy
and include them if the proxy is later marshaled.


Asynchronous Method Invocation Support
--------------------------------------

If HAS_AMI is enabled, the Ice-E client mapping and library will
include support for issuing remote invocations asynchronously with
guaranteed non-blocking semantics.


Installation
============

For installation instructions, please refer to the INSTALL.* file for
your platform.
