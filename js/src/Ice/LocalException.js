// **********************************************************************
//
// Copyright (c) 2003-2013 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************
//
// Ice version 3.5.1
//
// <auto-generated>
//
// Generated from file `LocalException.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

var __ice_Ex = require("./Exception");
var __ice_LocalException = __ice_Ex.LocalException;
var __ice_HashMap = require("./HashMap");

var Ice = (function(_mod_Ice, undefined)
{

    /// <summary>
    /// This exception is raised when a failure occurs during initialization.
    /// </summary>
    
    _mod_Ice.InitializationException = function(reason, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.reason = reason !== undefined ? reason : null;
    }
    _mod_Ice.InitializationException.prototype = new __ice_LocalException();
    _mod_Ice.InitializationException.prototype.constructor = _mod_Ice.InitializationException;

    _mod_Ice.InitializationException.prototype.ice_name = function()
    {
        return "Ice::InitializationException";
    }

    _mod_Ice.InitializationException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates that a failure occurred while initializing
    /// a plug-in.
    /// </summary>
    
    _mod_Ice.PluginInitializationException = function(reason, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.reason = reason !== undefined ? reason : null;
    }
    _mod_Ice.PluginInitializationException.prototype = new __ice_LocalException();
    _mod_Ice.PluginInitializationException.prototype.constructor = _mod_Ice.PluginInitializationException;

    _mod_Ice.PluginInitializationException.prototype.ice_name = function()
    {
        return "Ice::PluginInitializationException";
    }

    _mod_Ice.PluginInitializationException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if a feature is requested that is not
    /// supported with collocation optimization.
    /// </summary>
    
    _mod_Ice.CollocationOptimizationException = function(_cause)
    {
        __ice_LocalException.call(this, _cause);
    }
    _mod_Ice.CollocationOptimizationException.prototype = new __ice_LocalException();
    _mod_Ice.CollocationOptimizationException.prototype.constructor = _mod_Ice.CollocationOptimizationException;

    _mod_Ice.CollocationOptimizationException.prototype.ice_name = function()
    {
        return "Ice::CollocationOptimizationException";
    }

    _mod_Ice.CollocationOptimizationException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// An attempt was made to register something more than once with
    /// the Ice run time.
    /// This exception is raised if an attempt is made to register a
    /// servant, servant locator, facet, object factory, plug-in, object
    /// adapter, object, or user exception factory more than once for the
    /// same ID.
    /// </summary>
    
    _mod_Ice.AlreadyRegisteredException = function(kindOfObject, id, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.kindOfObject = kindOfObject !== undefined ? kindOfObject : null;
        this.id = id !== undefined ? id : null;
    }
    _mod_Ice.AlreadyRegisteredException.prototype = new __ice_LocalException();
    _mod_Ice.AlreadyRegisteredException.prototype.constructor = _mod_Ice.AlreadyRegisteredException;

    _mod_Ice.AlreadyRegisteredException.prototype.ice_name = function()
    {
        return "Ice::AlreadyRegisteredException";
    }

    _mod_Ice.AlreadyRegisteredException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// An attempt was made to find or deregister something that is not
    /// registered with the Ice run time or Ice locator.
    /// This exception is raised if an attempt is made to remove a servant,
    /// servant locator, facet, object factory, plug-in, object adapter, 
    /// object, or user exception factory that is not currently registered.
    /// 
    /// It's also raised if the Ice locator can't find an object or object
    /// adapter when resolving an indirect proxy or when an object adapter
    /// is activated.
    /// </summary>
    
    _mod_Ice.NotRegisteredException = function(kindOfObject, id, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.kindOfObject = kindOfObject !== undefined ? kindOfObject : null;
        this.id = id !== undefined ? id : null;
    }
    _mod_Ice.NotRegisteredException.prototype = new __ice_LocalException();
    _mod_Ice.NotRegisteredException.prototype.constructor = _mod_Ice.NotRegisteredException;

    _mod_Ice.NotRegisteredException.prototype.ice_name = function()
    {
        return "Ice::NotRegisteredException";
    }

    _mod_Ice.NotRegisteredException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// The operation can only be invoked with a twoway request.
    /// This exception is raised if an attempt is made to invoke an
    /// operation with ice_oneway, ice_batchOneway, ice_datagram,
    /// or ice_batchDatagram and the operation has a return value,
    /// out-parameters, or an exception specification.
    /// </summary>
    
    _mod_Ice.TwowayOnlyException = function(operation, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.operation = operation !== undefined ? operation : null;
    }
    _mod_Ice.TwowayOnlyException.prototype = new __ice_LocalException();
    _mod_Ice.TwowayOnlyException.prototype.constructor = _mod_Ice.TwowayOnlyException;

    _mod_Ice.TwowayOnlyException.prototype.ice_name = function()
    {
        return "Ice::TwowayOnlyException";
    }

    _mod_Ice.TwowayOnlyException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// An attempt was made to clone a class that does not support
    /// cloning.
    /// This exception is raised if ice_clone is called on
    /// a class that is derived from an abstract Slice class (that is,
    /// a class containing operations), and the derived class does not
    /// provide an implementation of the ice_clone operation (C++ only).
    /// </summary>
    
    _mod_Ice.CloneNotImplementedException = function(_cause)
    {
        __ice_LocalException.call(this, _cause);
    }
    _mod_Ice.CloneNotImplementedException.prototype = new __ice_LocalException();
    _mod_Ice.CloneNotImplementedException.prototype.constructor = _mod_Ice.CloneNotImplementedException;

    _mod_Ice.CloneNotImplementedException.prototype.ice_name = function()
    {
        return "Ice::CloneNotImplementedException";
    }

    _mod_Ice.CloneNotImplementedException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if an operation call on a server raises an
    /// unknown exception.
    /// For example, for C++, this exception is raised
    /// if the server throws a C++ exception that is not directly or
    /// indirectly derived from Ice::LocalException or
    /// Ice::UserException.
    /// </summary>
    
    _mod_Ice.UnknownException = function(unknown, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.unknown = unknown !== undefined ? unknown : null;
    }
    _mod_Ice.UnknownException.prototype = new __ice_LocalException();
    _mod_Ice.UnknownException.prototype.constructor = _mod_Ice.UnknownException;

    _mod_Ice.UnknownException.prototype.ice_name = function()
    {
        return "Ice::UnknownException";
    }

    _mod_Ice.UnknownException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if an operation call on a server raises a
    /// local exception.
    /// Because local exceptions are not transmitted by
    /// the Ice protocol, the client receives all local exceptions raised
    /// by the server as UnknownLocalException. The only exception to this
    /// rule are all exceptions derived from RequestFailedException,
    /// which are transmitted by the Ice protocol even though they are
    /// declared local.
    /// </summary>
    
    _mod_Ice.UnknownLocalException = function(unknown, _cause)
    {
        _mod_Ice.UnknownException.call(this, unknown, _cause);
    }
    _mod_Ice.UnknownLocalException.prototype = new _mod_Ice.UnknownException();
    _mod_Ice.UnknownLocalException.prototype.constructor = _mod_Ice.UnknownLocalException;

    _mod_Ice.UnknownLocalException.prototype.ice_name = function()
    {
        return "Ice::UnknownLocalException";
    }

    _mod_Ice.UnknownLocalException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// An operation raised an incorrect user exception.
    /// This exception is raised if an operation raises a
    /// user exception that is not declared in the exception's
    /// throws clause. Such undeclared exceptions are
    /// not transmitted from the server to the client by the Ice
    /// protocol, but instead the client just gets an
    /// UnknownUserException. This is necessary in order to not violate
    /// the contract established by an operation's signature: Only local
    /// exceptions and user exceptions declared in the
    /// throws clause can be raised.
    /// </summary>
    
    _mod_Ice.UnknownUserException = function(unknown, _cause)
    {
        _mod_Ice.UnknownException.call(this, unknown, _cause);
    }
    _mod_Ice.UnknownUserException.prototype = new _mod_Ice.UnknownException();
    _mod_Ice.UnknownUserException.prototype.constructor = _mod_Ice.UnknownUserException;

    _mod_Ice.UnknownUserException.prototype.ice_name = function()
    {
        return "Ice::UnknownUserException";
    }

    _mod_Ice.UnknownUserException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if the Ice library version does not match
    /// the version in the Ice header files.
    /// </summary>
    
    _mod_Ice.VersionMismatchException = function(_cause)
    {
        __ice_LocalException.call(this, _cause);
    }
    _mod_Ice.VersionMismatchException.prototype = new __ice_LocalException();
    _mod_Ice.VersionMismatchException.prototype.constructor = _mod_Ice.VersionMismatchException;

    _mod_Ice.VersionMismatchException.prototype.ice_name = function()
    {
        return "Ice::VersionMismatchException";
    }

    _mod_Ice.VersionMismatchException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if the Communicator has been destroyed.
    /// </summary>
    
    _mod_Ice.CommunicatorDestroyedException = function(_cause)
    {
        __ice_LocalException.call(this, _cause);
    }
    _mod_Ice.CommunicatorDestroyedException.prototype = new __ice_LocalException();
    _mod_Ice.CommunicatorDestroyedException.prototype.constructor = _mod_Ice.CommunicatorDestroyedException;

    _mod_Ice.CommunicatorDestroyedException.prototype.ice_name = function()
    {
        return "Ice::CommunicatorDestroyedException";
    }

    _mod_Ice.CommunicatorDestroyedException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if an attempt is made to use a deactivated
    /// ObjectAdapter.
    /// </summary>
    
    _mod_Ice.ObjectAdapterDeactivatedException = function(name, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.name = name !== undefined ? name : null;
    }
    _mod_Ice.ObjectAdapterDeactivatedException.prototype = new __ice_LocalException();
    _mod_Ice.ObjectAdapterDeactivatedException.prototype.constructor = _mod_Ice.ObjectAdapterDeactivatedException;

    _mod_Ice.ObjectAdapterDeactivatedException.prototype.ice_name = function()
    {
        return "Ice::ObjectAdapterDeactivatedException";
    }

    _mod_Ice.ObjectAdapterDeactivatedException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if an ObjectAdapter cannot be activated.
    /// This happens if the Locator detects another active ObjectAdapter with
    /// the same adapter id.
    /// </summary>
    
    _mod_Ice.ObjectAdapterIdInUseException = function(id, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.id = id !== undefined ? id : null;
    }
    _mod_Ice.ObjectAdapterIdInUseException.prototype = new __ice_LocalException();
    _mod_Ice.ObjectAdapterIdInUseException.prototype.constructor = _mod_Ice.ObjectAdapterIdInUseException;

    _mod_Ice.ObjectAdapterIdInUseException.prototype.ice_name = function()
    {
        return "Ice::ObjectAdapterIdInUseException";
    }

    _mod_Ice.ObjectAdapterIdInUseException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if no suitable endpoint is available.
    /// </summary>
    
    _mod_Ice.NoEndpointException = function(proxy, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.proxy = proxy !== undefined ? proxy : null;
    }
    _mod_Ice.NoEndpointException.prototype = new __ice_LocalException();
    _mod_Ice.NoEndpointException.prototype.constructor = _mod_Ice.NoEndpointException;

    _mod_Ice.NoEndpointException.prototype.ice_name = function()
    {
        return "Ice::NoEndpointException";
    }

    _mod_Ice.NoEndpointException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if there was an error while parsing an
    /// endpoint.
    /// </summary>
    
    _mod_Ice.EndpointParseException = function(str, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.str = str !== undefined ? str : null;
    }
    _mod_Ice.EndpointParseException.prototype = new __ice_LocalException();
    _mod_Ice.EndpointParseException.prototype.constructor = _mod_Ice.EndpointParseException;

    _mod_Ice.EndpointParseException.prototype.ice_name = function()
    {
        return "Ice::EndpointParseException";
    }

    _mod_Ice.EndpointParseException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if there was an error while parsing an
    /// endpoint selection type.
    /// </summary>
    
    _mod_Ice.EndpointSelectionTypeParseException = function(str, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.str = str !== undefined ? str : null;
    }
    _mod_Ice.EndpointSelectionTypeParseException.prototype = new __ice_LocalException();
    _mod_Ice.EndpointSelectionTypeParseException.prototype.constructor = _mod_Ice.EndpointSelectionTypeParseException;

    _mod_Ice.EndpointSelectionTypeParseException.prototype.ice_name = function()
    {
        return "Ice::EndpointSelectionTypeParseException";
    }

    _mod_Ice.EndpointSelectionTypeParseException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if there was an error while parsing a
    /// version.
    /// </summary>
    
    _mod_Ice.VersionParseException = function(str, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.str = str !== undefined ? str : null;
    }
    _mod_Ice.VersionParseException.prototype = new __ice_LocalException();
    _mod_Ice.VersionParseException.prototype.constructor = _mod_Ice.VersionParseException;

    _mod_Ice.VersionParseException.prototype.ice_name = function()
    {
        return "Ice::VersionParseException";
    }

    _mod_Ice.VersionParseException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if there was an error while parsing a
    /// stringified identity.
    /// </summary>
    
    _mod_Ice.IdentityParseException = function(str, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.str = str !== undefined ? str : null;
    }
    _mod_Ice.IdentityParseException.prototype = new __ice_LocalException();
    _mod_Ice.IdentityParseException.prototype.constructor = _mod_Ice.IdentityParseException;

    _mod_Ice.IdentityParseException.prototype.ice_name = function()
    {
        return "Ice::IdentityParseException";
    }

    _mod_Ice.IdentityParseException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if there was an error while parsing a
    /// stringified proxy.
    /// </summary>
    
    _mod_Ice.ProxyParseException = function(str, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.str = str !== undefined ? str : null;
    }
    _mod_Ice.ProxyParseException.prototype = new __ice_LocalException();
    _mod_Ice.ProxyParseException.prototype.constructor = _mod_Ice.ProxyParseException;

    _mod_Ice.ProxyParseException.prototype.ice_name = function()
    {
        return "Ice::ProxyParseException";
    }

    _mod_Ice.ProxyParseException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if an illegal identity is encountered.
    /// </summary>
    
    _mod_Ice.IllegalIdentityException = function(id, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.id = id !== undefined ? id : null;
    }
    _mod_Ice.IllegalIdentityException.prototype = new __ice_LocalException();
    _mod_Ice.IllegalIdentityException.prototype.constructor = _mod_Ice.IllegalIdentityException;

    _mod_Ice.IllegalIdentityException.prototype.ice_name = function()
    {
        return "Ice::IllegalIdentityException";
    }

    _mod_Ice.IllegalIdentityException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if a request failed.
    /// This exception, and
    /// all exceptions derived from RequestFailedException, are
    /// transmitted by the Ice protocol, even though they are declared
    /// local.
    /// </summary>
    
    _mod_Ice.RequestFailedException = function(id, facet, operation, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.id = id !== undefined ? id : null;
        this.facet = facet !== undefined ? facet : null;
        this.operation = operation !== undefined ? operation : null;
    }
    _mod_Ice.RequestFailedException.prototype = new __ice_LocalException();
    _mod_Ice.RequestFailedException.prototype.constructor = _mod_Ice.RequestFailedException;

    _mod_Ice.RequestFailedException.prototype.ice_name = function()
    {
        return "Ice::RequestFailedException";
    }

    _mod_Ice.RequestFailedException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if an object does not exist on the server,
    /// that is, if no facets with the given identity exist.
    /// </summary>
    
    _mod_Ice.ObjectNotExistException = function(id, facet, operation, _cause)
    {
        _mod_Ice.RequestFailedException.call(this, id, facet, operation, _cause);
    }
    _mod_Ice.ObjectNotExistException.prototype = new _mod_Ice.RequestFailedException();
    _mod_Ice.ObjectNotExistException.prototype.constructor = _mod_Ice.ObjectNotExistException;

    _mod_Ice.ObjectNotExistException.prototype.ice_name = function()
    {
        return "Ice::ObjectNotExistException";
    }

    _mod_Ice.ObjectNotExistException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if no facet with the given name exists,
    /// but at least one facet with the given identity exists.
    /// </summary>
    
    _mod_Ice.FacetNotExistException = function(id, facet, operation, _cause)
    {
        _mod_Ice.RequestFailedException.call(this, id, facet, operation, _cause);
    }
    _mod_Ice.FacetNotExistException.prototype = new _mod_Ice.RequestFailedException();
    _mod_Ice.FacetNotExistException.prototype.constructor = _mod_Ice.FacetNotExistException;

    _mod_Ice.FacetNotExistException.prototype.ice_name = function()
    {
        return "Ice::FacetNotExistException";
    }

    _mod_Ice.FacetNotExistException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if an operation for a given object does
    /// not exist on the server.
    /// Typically this is caused by either the
    /// client or the server using an outdated Slice specification.
    /// </summary>
    
    _mod_Ice.OperationNotExistException = function(id, facet, operation, _cause)
    {
        _mod_Ice.RequestFailedException.call(this, id, facet, operation, _cause);
    }
    _mod_Ice.OperationNotExistException.prototype = new _mod_Ice.RequestFailedException();
    _mod_Ice.OperationNotExistException.prototype.constructor = _mod_Ice.OperationNotExistException;

    _mod_Ice.OperationNotExistException.prototype.ice_name = function()
    {
        return "Ice::OperationNotExistException";
    }

    _mod_Ice.OperationNotExistException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if a system error occurred in the server
    /// or client process.
    /// There are many possible causes for such a system
    /// exception. For details on the cause, SyscallException.error
    /// should be inspected.
    /// </summary>
    
    _mod_Ice.SyscallException = function(error, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.error = error !== undefined ? error : 0;
    }
    _mod_Ice.SyscallException.prototype = new __ice_LocalException();
    _mod_Ice.SyscallException.prototype.constructor = _mod_Ice.SyscallException;

    _mod_Ice.SyscallException.prototype.ice_name = function()
    {
        return "Ice::SyscallException";
    }

    _mod_Ice.SyscallException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates socket errors.
    /// </summary>
    
    _mod_Ice.SocketException = function(error, _cause)
    {
        _mod_Ice.SyscallException.call(this, error, _cause);
    }
    _mod_Ice.SocketException.prototype = new _mod_Ice.SyscallException();
    _mod_Ice.SocketException.prototype.constructor = _mod_Ice.SocketException;

    _mod_Ice.SocketException.prototype.ice_name = function()
    {
        return "Ice::SocketException";
    }

    _mod_Ice.SocketException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates file errors.
    /// </summary>
    
    _mod_Ice.FileException = function(error, path, _cause)
    {
        _mod_Ice.SyscallException.call(this, error, _cause);
        this.path = path !== undefined ? path : null;
    }
    _mod_Ice.FileException.prototype = new _mod_Ice.SyscallException();
    _mod_Ice.FileException.prototype.constructor = _mod_Ice.FileException;

    _mod_Ice.FileException.prototype.ice_name = function()
    {
        return "Ice::FileException";
    }

    _mod_Ice.FileException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates connection failures.
    /// </summary>
    
    _mod_Ice.ConnectFailedException = function(error, _cause)
    {
        _mod_Ice.SocketException.call(this, error, _cause);
    }
    _mod_Ice.ConnectFailedException.prototype = new _mod_Ice.SocketException();
    _mod_Ice.ConnectFailedException.prototype.constructor = _mod_Ice.ConnectFailedException;

    _mod_Ice.ConnectFailedException.prototype.ice_name = function()
    {
        return "Ice::ConnectFailedException";
    }

    _mod_Ice.ConnectFailedException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates a connection failure for which
    /// the server host actively refuses a connection.
    /// </summary>
    
    _mod_Ice.ConnectionRefusedException = function(error, _cause)
    {
        _mod_Ice.ConnectFailedException.call(this, error, _cause);
    }
    _mod_Ice.ConnectionRefusedException.prototype = new _mod_Ice.ConnectFailedException();
    _mod_Ice.ConnectionRefusedException.prototype.constructor = _mod_Ice.ConnectionRefusedException;

    _mod_Ice.ConnectionRefusedException.prototype.ice_name = function()
    {
        return "Ice::ConnectionRefusedException";
    }

    _mod_Ice.ConnectionRefusedException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates a lost connection.
    /// </summary>
    
    _mod_Ice.ConnectionLostException = function(error, _cause)
    {
        _mod_Ice.SocketException.call(this, error, _cause);
    }
    _mod_Ice.ConnectionLostException.prototype = new _mod_Ice.SocketException();
    _mod_Ice.ConnectionLostException.prototype.constructor = _mod_Ice.ConnectionLostException;

    _mod_Ice.ConnectionLostException.prototype.ice_name = function()
    {
        return "Ice::ConnectionLostException";
    }

    _mod_Ice.ConnectionLostException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates a DNS problem.
    /// For details on the cause,
    /// DNSException.error should be inspected.
    /// </summary>
    
    _mod_Ice.DNSException = function(error, host, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.error = error !== undefined ? error : 0;
        this.host = host !== undefined ? host : null;
    }
    _mod_Ice.DNSException.prototype = new __ice_LocalException();
    _mod_Ice.DNSException.prototype.constructor = _mod_Ice.DNSException;

    _mod_Ice.DNSException.prototype.ice_name = function()
    {
        return "Ice::DNSException";
    }

    _mod_Ice.DNSException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates a timeout condition.
    /// </summary>
    
    _mod_Ice.TimeoutException = function(_cause)
    {
        __ice_LocalException.call(this, _cause);
    }
    _mod_Ice.TimeoutException.prototype = new __ice_LocalException();
    _mod_Ice.TimeoutException.prototype.constructor = _mod_Ice.TimeoutException;

    _mod_Ice.TimeoutException.prototype.ice_name = function()
    {
        return "Ice::TimeoutException";
    }

    _mod_Ice.TimeoutException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates a connection establishment timeout condition.
    /// </summary>
    
    _mod_Ice.ConnectTimeoutException = function(_cause)
    {
        _mod_Ice.TimeoutException.call(this, _cause);
    }
    _mod_Ice.ConnectTimeoutException.prototype = new _mod_Ice.TimeoutException();
    _mod_Ice.ConnectTimeoutException.prototype.constructor = _mod_Ice.ConnectTimeoutException;

    _mod_Ice.ConnectTimeoutException.prototype.ice_name = function()
    {
        return "Ice::ConnectTimeoutException";
    }

    _mod_Ice.ConnectTimeoutException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates a connection closure timeout condition.
    /// </summary>
    
    _mod_Ice.CloseTimeoutException = function(_cause)
    {
        _mod_Ice.TimeoutException.call(this, _cause);
    }
    _mod_Ice.CloseTimeoutException.prototype = new _mod_Ice.TimeoutException();
    _mod_Ice.CloseTimeoutException.prototype.constructor = _mod_Ice.CloseTimeoutException;

    _mod_Ice.CloseTimeoutException.prototype.ice_name = function()
    {
        return "Ice::CloseTimeoutException";
    }

    _mod_Ice.CloseTimeoutException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates that a connection has been shut down because it has been
    /// idle for some time.
    /// </summary>
    
    _mod_Ice.ConnectionTimeoutException = function(_cause)
    {
        _mod_Ice.TimeoutException.call(this, _cause);
    }
    _mod_Ice.ConnectionTimeoutException.prototype = new _mod_Ice.TimeoutException();
    _mod_Ice.ConnectionTimeoutException.prototype.constructor = _mod_Ice.ConnectionTimeoutException;

    _mod_Ice.ConnectionTimeoutException.prototype.ice_name = function()
    {
        return "Ice::ConnectionTimeoutException";
    }

    _mod_Ice.ConnectionTimeoutException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// A generic exception base for all kinds of protocol error
    /// conditions.
    /// </summary>
    
    _mod_Ice.ProtocolException = function(reason, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.reason = reason !== undefined ? reason : null;
    }
    _mod_Ice.ProtocolException.prototype = new __ice_LocalException();
    _mod_Ice.ProtocolException.prototype.constructor = _mod_Ice.ProtocolException;

    _mod_Ice.ProtocolException.prototype.ice_name = function()
    {
        return "Ice::ProtocolException";
    }

    _mod_Ice.ProtocolException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates that a message did not start with the expected
    /// magic number ('I', 'c', 'e', 'P').
    /// </summary>
    
    _mod_Ice.BadMagicException = function(reason, badMagic, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
        this.badMagic = badMagic !== undefined ? badMagic : null;
    }
    _mod_Ice.BadMagicException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.BadMagicException.prototype.constructor = _mod_Ice.BadMagicException;

    _mod_Ice.BadMagicException.prototype.ice_name = function()
    {
        return "Ice::BadMagicException";
    }

    _mod_Ice.BadMagicException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates an unsupported protocol version.
    /// </summary>
    
    _mod_Ice.UnsupportedProtocolException = function(reason, bad, supported, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
        this.bad = bad !== undefined ? bad : null;
        this.supported = supported !== undefined ? supported : null;
    }
    _mod_Ice.UnsupportedProtocolException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.UnsupportedProtocolException.prototype.constructor = _mod_Ice.UnsupportedProtocolException;

    _mod_Ice.UnsupportedProtocolException.prototype.ice_name = function()
    {
        return "Ice::UnsupportedProtocolException";
    }

    _mod_Ice.UnsupportedProtocolException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates an unsupported data encoding version.
    /// </summary>
    
    _mod_Ice.UnsupportedEncodingException = function(reason, bad, supported, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
        this.bad = bad !== undefined ? bad : null;
        this.supported = supported !== undefined ? supported : null;
    }
    _mod_Ice.UnsupportedEncodingException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.UnsupportedEncodingException.prototype.constructor = _mod_Ice.UnsupportedEncodingException;

    _mod_Ice.UnsupportedEncodingException.prototype.ice_name = function()
    {
        return "Ice::UnsupportedEncodingException";
    }

    _mod_Ice.UnsupportedEncodingException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates that an unknown protocol message has been received.
    /// </summary>
    
    _mod_Ice.UnknownMessageException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.UnknownMessageException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.UnknownMessageException.prototype.constructor = _mod_Ice.UnknownMessageException;

    _mod_Ice.UnknownMessageException.prototype.ice_name = function()
    {
        return "Ice::UnknownMessageException";
    }

    _mod_Ice.UnknownMessageException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if a message is received over a connection
    /// that is not yet validated.
    /// </summary>
    
    _mod_Ice.ConnectionNotValidatedException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.ConnectionNotValidatedException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.ConnectionNotValidatedException.prototype.constructor = _mod_Ice.ConnectionNotValidatedException;

    _mod_Ice.ConnectionNotValidatedException.prototype.ice_name = function()
    {
        return "Ice::ConnectionNotValidatedException";
    }

    _mod_Ice.ConnectionNotValidatedException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates that a response for an unknown request ID has been
    /// received.
    /// </summary>
    
    _mod_Ice.UnknownRequestIdException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.UnknownRequestIdException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.UnknownRequestIdException.prototype.constructor = _mod_Ice.UnknownRequestIdException;

    _mod_Ice.UnknownRequestIdException.prototype.ice_name = function()
    {
        return "Ice::UnknownRequestIdException";
    }

    _mod_Ice.UnknownRequestIdException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates that an unknown reply status has been received.
    /// </summary>
    
    _mod_Ice.UnknownReplyStatusException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.UnknownReplyStatusException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.UnknownReplyStatusException.prototype.constructor = _mod_Ice.UnknownReplyStatusException;

    _mod_Ice.UnknownReplyStatusException.prototype.ice_name = function()
    {
        return "Ice::UnknownReplyStatusException";
    }

    _mod_Ice.UnknownReplyStatusException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates that the connection has been gracefully shut down by the
    /// server.
    /// The operation call that caused this exception has not been
    /// executed by the server. In most cases you will not get this
    /// exception, because the client will automatically retry the
    /// operation call in case the server shut down the connection. However,
    /// if upon retry the server shuts down the connection again, and the
    /// retry limit has been reached, then this exception is propagated to
    /// the application code.
    /// </summary>
    
    _mod_Ice.CloseConnectionException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.CloseConnectionException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.CloseConnectionException.prototype.constructor = _mod_Ice.CloseConnectionException;

    _mod_Ice.CloseConnectionException.prototype.ice_name = function()
    {
        return "Ice::CloseConnectionException";
    }

    _mod_Ice.CloseConnectionException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised by an operation call if the application
    /// forcefully closes the connection Connection.close.
    /// </summary>
    
    _mod_Ice.ForcedCloseConnectionException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.ForcedCloseConnectionException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.ForcedCloseConnectionException.prototype.constructor = _mod_Ice.ForcedCloseConnectionException;

    _mod_Ice.ForcedCloseConnectionException.prototype.ice_name = function()
    {
        return "Ice::ForcedCloseConnectionException";
    }

    _mod_Ice.ForcedCloseConnectionException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates that a message size is less
    /// than the minimum required size.
    /// </summary>
    
    _mod_Ice.IllegalMessageSizeException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.IllegalMessageSizeException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.IllegalMessageSizeException.prototype.constructor = _mod_Ice.IllegalMessageSizeException;

    _mod_Ice.IllegalMessageSizeException.prototype.ice_name = function()
    {
        return "Ice::IllegalMessageSizeException";
    }

    _mod_Ice.IllegalMessageSizeException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates a problem with compressing or uncompressing data.
    /// </summary>
    
    _mod_Ice.CompressionException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.CompressionException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.CompressionException.prototype.constructor = _mod_Ice.CompressionException;

    _mod_Ice.CompressionException.prototype.ice_name = function()
    {
        return "Ice::CompressionException";
    }

    _mod_Ice.CompressionException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// A datagram exceeds the configured size.
    /// This exception is raised if a datagram exceeds the configured send or receive buffer
    /// size, or exceeds the maximum payload size of a UDP packet (65507 bytes).
    /// </summary>
    
    _mod_Ice.DatagramLimitException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.DatagramLimitException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.DatagramLimitException.prototype.constructor = _mod_Ice.DatagramLimitException;

    _mod_Ice.DatagramLimitException.prototype.ice_name = function()
    {
        return "Ice::DatagramLimitException";
    }

    _mod_Ice.DatagramLimitException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised for errors during marshaling or unmarshaling data.
    /// </summary>
    
    _mod_Ice.MarshalException = function(reason, _cause)
    {
        _mod_Ice.ProtocolException.call(this, reason, _cause);
    }
    _mod_Ice.MarshalException.prototype = new _mod_Ice.ProtocolException();
    _mod_Ice.MarshalException.prototype.constructor = _mod_Ice.MarshalException;

    _mod_Ice.MarshalException.prototype.ice_name = function()
    {
        return "Ice::MarshalException";
    }

    _mod_Ice.MarshalException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if inconsistent data is received while unmarshaling a proxy.
    /// </summary>
    
    _mod_Ice.ProxyUnmarshalException = function(reason, _cause)
    {
        _mod_Ice.MarshalException.call(this, reason, _cause);
    }
    _mod_Ice.ProxyUnmarshalException.prototype = new _mod_Ice.MarshalException();
    _mod_Ice.ProxyUnmarshalException.prototype.constructor = _mod_Ice.ProxyUnmarshalException;

    _mod_Ice.ProxyUnmarshalException.prototype.ice_name = function()
    {
        return "Ice::ProxyUnmarshalException";
    }

    _mod_Ice.ProxyUnmarshalException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if an out-of-bounds condition occurs during unmarshaling.
    /// </summary>
    
    _mod_Ice.UnmarshalOutOfBoundsException = function(reason, _cause)
    {
        _mod_Ice.MarshalException.call(this, reason, _cause);
    }
    _mod_Ice.UnmarshalOutOfBoundsException.prototype = new _mod_Ice.MarshalException();
    _mod_Ice.UnmarshalOutOfBoundsException.prototype.constructor = _mod_Ice.UnmarshalOutOfBoundsException;

    _mod_Ice.UnmarshalOutOfBoundsException.prototype.ice_name = function()
    {
        return "Ice::UnmarshalOutOfBoundsException";
    }

    _mod_Ice.UnmarshalOutOfBoundsException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if no suitable object factory was found during
    /// unmarshaling of a Slice class instance.
    /// </summary>
    
    _mod_Ice.NoObjectFactoryException = function(reason, type, _cause)
    {
        _mod_Ice.MarshalException.call(this, reason, _cause);
        this.type = type !== undefined ? type : null;
    }
    _mod_Ice.NoObjectFactoryException.prototype = new _mod_Ice.MarshalException();
    _mod_Ice.NoObjectFactoryException.prototype.constructor = _mod_Ice.NoObjectFactoryException;

    _mod_Ice.NoObjectFactoryException.prototype.ice_name = function()
    {
        return "Ice::NoObjectFactoryException";
    }

    _mod_Ice.NoObjectFactoryException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if the type of an unmarshaled Slice class instance does
    /// not match its expected type.
    /// This can happen if client and server are compiled with mismatched Slice
    /// definitions or if a class of the wrong type is passed as a parameter
    /// or return value using dynamic invocation. This exception can also be
    /// raised if IceStorm is used to send Slice class instances and
    /// an operation is subscribed to the wrong topic.
    /// </summary>
    
    _mod_Ice.UnexpectedObjectException = function(reason, type, expectedType, _cause)
    {
        _mod_Ice.MarshalException.call(this, reason, _cause);
        this.type = type !== undefined ? type : null;
        this.expectedType = expectedType !== undefined ? expectedType : null;
    }
    _mod_Ice.UnexpectedObjectException.prototype = new _mod_Ice.MarshalException();
    _mod_Ice.UnexpectedObjectException.prototype.constructor = _mod_Ice.UnexpectedObjectException;

    _mod_Ice.UnexpectedObjectException.prototype.ice_name = function()
    {
        return "Ice::UnexpectedObjectException";
    }

    _mod_Ice.UnexpectedObjectException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if a request size exceeds the limit specified by the Ice.MessageSizeMax property.
    /// </summary>
    
    _mod_Ice.MemoryLimitException = function(reason, _cause)
    {
        _mod_Ice.MarshalException.call(this, reason, _cause);
    }
    _mod_Ice.MemoryLimitException.prototype = new _mod_Ice.MarshalException();
    _mod_Ice.MemoryLimitException.prototype.constructor = _mod_Ice.MemoryLimitException;

    _mod_Ice.MemoryLimitException.prototype.ice_name = function()
    {
        return "Ice::MemoryLimitException";
    }

    _mod_Ice.MemoryLimitException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is
    /// raised when a string conversion to or from UTF-8 fails during 
    /// marshaling or unmarshaling.
    /// </summary>
    
    _mod_Ice.StringConversionException = function(reason, _cause)
    {
        _mod_Ice.MarshalException.call(this, reason, _cause);
    }
    _mod_Ice.StringConversionException.prototype = new _mod_Ice.MarshalException();
    _mod_Ice.StringConversionException.prototype.constructor = _mod_Ice.StringConversionException;

    _mod_Ice.StringConversionException.prototype.ice_name = function()
    {
        return "Ice::StringConversionException";
    }

    _mod_Ice.StringConversionException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates a malformed data encapsulation.
    /// </summary>
    
    _mod_Ice.EncapsulationException = function(reason, _cause)
    {
        _mod_Ice.MarshalException.call(this, reason, _cause);
    }
    _mod_Ice.EncapsulationException.prototype = new _mod_Ice.MarshalException();
    _mod_Ice.EncapsulationException.prototype.constructor = _mod_Ice.EncapsulationException;

    _mod_Ice.EncapsulationException.prototype.ice_name = function()
    {
        return "Ice::EncapsulationException";
    }

    _mod_Ice.EncapsulationException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception is raised if an unsupported feature is used.
    /// The
    /// unsupported feature string contains the name of the unsupported
    /// feature
    /// </summary>
    
    _mod_Ice.FeatureNotSupportedException = function(unsupportedFeature, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.unsupportedFeature = unsupportedFeature !== undefined ? unsupportedFeature : null;
    }
    _mod_Ice.FeatureNotSupportedException.prototype = new __ice_LocalException();
    _mod_Ice.FeatureNotSupportedException.prototype.constructor = _mod_Ice.FeatureNotSupportedException;

    _mod_Ice.FeatureNotSupportedException.prototype.ice_name = function()
    {
        return "Ice::FeatureNotSupportedException";
    }

    _mod_Ice.FeatureNotSupportedException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates a failure in a security subsystem,
    /// such as the IceSSL plug-in.
    /// </summary>
    
    _mod_Ice.SecurityException = function(reason, _cause)
    {
        __ice_LocalException.call(this, _cause);
        this.reason = reason !== undefined ? reason : null;
    }
    _mod_Ice.SecurityException.prototype = new __ice_LocalException();
    _mod_Ice.SecurityException.prototype.constructor = _mod_Ice.SecurityException;

    _mod_Ice.SecurityException.prototype.ice_name = function()
    {
        return "Ice::SecurityException";
    }

    _mod_Ice.SecurityException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// This exception indicates that an attempt has been made to
    /// change the connection properties of a fixed proxy.
    /// </summary>
    
    _mod_Ice.FixedProxyException = function(_cause)
    {
        __ice_LocalException.call(this, _cause);
    }
    _mod_Ice.FixedProxyException.prototype = new __ice_LocalException();
    _mod_Ice.FixedProxyException.prototype.constructor = _mod_Ice.FixedProxyException;

    _mod_Ice.FixedProxyException.prototype.ice_name = function()
    {
        return "Ice::FixedProxyException";
    }

    _mod_Ice.FixedProxyException.prototype.toString = function()
    {
        return this.ice_name();
    }

    /// <summary>
    /// Indicates that the response to a request has already been sent;
    /// re-dispatching such a request is not possible.
    /// </summary>
    
    _mod_Ice.ResponseSentException = function(_cause)
    {
        __ice_LocalException.call(this, _cause);
    }
    _mod_Ice.ResponseSentException.prototype = new __ice_LocalException();
    _mod_Ice.ResponseSentException.prototype.constructor = _mod_Ice.ResponseSentException;

    _mod_Ice.ResponseSentException.prototype.ice_name = function()
    {
        return "Ice::ResponseSentException";
    }

    _mod_Ice.ResponseSentException.prototype.toString = function()
    {
        return this.ice_name();
    }

    return _mod_Ice;
}(Ice || {}));

module.exports.Ice = Ice;
