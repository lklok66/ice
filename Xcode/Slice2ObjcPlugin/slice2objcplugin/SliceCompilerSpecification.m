// **********************************************************************
//
// Copyright (c) 2003-2009 ZeroC, Inc. All rights reserved.
//
// This copy of Ice is licensed to you under the terms described in the
// ICE_LICENSE file included in this distribution.
//
// **********************************************************************

#import <SliceCompilerSpecification.h>
#import <XCPBuildSystem.h>
#import <XCPDependencyGraph.h>
#import <XCPSupport.h>

@interface XMLSliceParserDelegate : NSObject
{
@private
    
    NSMutableArray* depends;
}

- (void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI
    qualifiedName:(NSString *)qualifiedName attributes:(NSDictionary *)attributeDict;

@property(nonatomic, readonly) NSArray* depends;

@end

@implementation XMLSliceParserDelegate

@synthesize depends;

-(id)init
{
    if(![super init])
    {
        return nil;
    }
    depends = [[NSMutableArray alloc] init];
    return self;
}

-(void)parser:(NSXMLParser *)parser didStartElement:(NSString *)elementName namespaceURI:(NSString *)namespaceURI
    qualifiedName:(NSString *)qualifiedName attributes:(NSDictionary *)attributeDict
{
    if([elementName compare:@"dependsOn"] == NSOrderedSame)
    {
        NSString* name = [attributeDict objectForKey:@"name"];
        if(name != 0)
        {
            [depends addObject:name];
        }
    }
    
}

-(void)dealloc
{
    [depends release];
    [super dealloc];
}

@end

@implementation SliceCompilerSpecification
+ (void) initialize
{
	PBXFileType* type = (PBXFileType*)[PBXFileType specificationForIdentifier:@"sourcecode.slice"];
	XCCompilerSpecification* spec = (XCCompilerSpecification*)[XCCompilerSpecification specificationForIdentifier:@"com.zeroc.compilers.slice"];
	[PBXTargetBuildContext activateImportedFileType:type withCompiler:spec];
}

-(NSString*)getIceHome:(PBXTargetBuildContext*)context
{
    NSString* iceHome = [context expandedValueForString:@"$(SLICE_ICE_HOME)"];
    NSString* iceHomeCpp = [NSString stringWithFormat:@"%@/cpp", iceHome];
    BOOL dir;
    if([[NSFileManager defaultManager] fileExistsAtPath:iceHomeCpp isDirectory:&dir] && dir)
    {
        return iceHomeCpp;
    }
    return iceHome;
}

-(NSString*)getSliceTranslator:(PBXTargetBuildContext*)context isCpp:(BOOL*)slice2cpp
{
    NSString* iceHome = [self getIceHome:context];
    
    *slice2cpp = [[context expandedValueForString:@"$(SLICE_CPP_FLAG)"] compare:@"YES"] == NSOrderedSame;
    NSString* exe = (*slice2cpp) ? @"slice2cpp" : @"slice2objc";
    return [NSString stringWithFormat:@"%@/bin/%@", iceHome, exe];
}

-(NSString*)getSliceSharedLibrary:(PBXTargetBuildContext*)context
{
    NSString* iceHome = [self getIceHome:context];
    return [NSString stringWithFormat:@"%@/lib", iceHome];
}

// Run the slice compiler with --depend-xml to determine the dependencies for the given slice file.
-(NSArray*)dependenciesForSliceFile:(NSString*)path context:(PBXTargetBuildContext*)context
{
    NSMutableDictionary* env = [[[NSProcessInfo processInfo] environment] mutableCopy];
    NSString* shlib = [env objectForKey:@"DYLD_LIBRARY_PATH"];
    if(shlib != 0)
    {
        shlib = [shlib stringByAppendingFormat:@":%@", [self getSliceSharedLibrary:context]];
    }
    else
    {
        shlib = [self getSliceSharedLibrary:context];
    }
    [env setObject:shlib forKey:@"DYLD_LIBRARY_PATH"];
    
    NSTask *dependTask = [[[NSTask alloc] init] autorelease];
    NSMutableArray *args = [NSMutableArray array];

    BOOL slice2cpp;
    [dependTask setLaunchPath:[self getSliceTranslator:context isCpp:&slice2cpp]];
    [dependTask setEnvironment:env];
    [dependTask setCurrentDirectoryPath:[context baseDirectoryPath]];
    
    NSPipe* newPipe = [NSPipe pipe];
    NSFileHandle* readHandle = [newPipe fileHandleForReading];
    NSData* inData = nil;
    
    // write handle is closed to this process
    [dependTask setStandardOutput:newPipe];
    // Stderr goes no-where.
    //[dependTask setStandardError:newPipe];
    
    /* set arguments */
    [args addObjectsFromArray:[self commandLineForAutogeneratedOptionsInTargetBuildContext:context]];
    [args addObjectsFromArray:[[context expandedValueForString:@"$(build_file_compiler_flags)"] arrayByParsingAsStringList]];
    
    if(slice2cpp)
    {
        [args addObject:@"--depend"];
    }
    else
    {
        [args addObject:@"--depend-xml"];
    }
    [args addObject:path];
    
    //NSLog(@"args: %@", args);
    
    [dependTask setArguments:args];
    
    [dependTask launch];
    
    NSMutableData* output = [[[NSMutableData alloc] init] autorelease];
    while ((inData = [readHandle availableData]) && [inData length])
    {
        [output appendData:inData];
    }

    [dependTask waitUntilExit];
    if([dependTask terminationStatus] != 0)
    {
        NSLog(@"translator exited with non-zero status %d", [dependTask terminationStatus]);
        return [NSArray array];
    }
    
    if(slice2cpp)
    {
        NSMutableArray* dep = [NSMutableArray array];
        NSString* soutput = [[[NSString alloc]initWithData:output encoding:NSUTF8StringEncoding] autorelease];
        // Parse C++ style dependencies.
        NSArray* lines = [soutput componentsSeparatedByString:@"\n"];
        // Ignore the first two lines.
        if(lines.count > 2)
        {
            NSEnumerator *e = [lines objectEnumerator];
            [e nextObject]; // Foo.cpp
            [e nextObject]; // Foo.m
            // The remaning lines are the dependencies themselves.
            NSString* line;
            while (line = [e nextObject])
            {
                // Strip the trailing \ if any.
                if([line characterAtIndex:line.length-1] == '\\')
                {
                    line = [line substringToIndex:line.length-1];
                }
                // Strip leading and trailing whitespace
                line = [line stringByTrimmingCharactersInSet:[NSCharacterSet whitespaceCharacterSet]];
                // Don't add empty dependencies.
                if(line.length > 0)
                {
                    [dep addObject:line];
                }
            }
        }
        return dep;
    }
    else
    {
        // Parse XML style dependencies.
        XMLSliceParserDelegate* del = [[[XMLSliceParserDelegate alloc] init] autorelease];
        NSXMLParser* parser = [[[NSXMLParser alloc] initWithData:output] autorelease];
        [parser setDelegate:del];
        BOOL success = [parser parse];
        if(!success)
        {
            NSLog(@"XML parse of dependencies failed\n%@", output);
            return [NSArray array];
        }
        return [del depends];
    }
}

- (NSArray*) computeDependenciesForFilePath:(NSString*)input ofType:(PBXFileType*)type outputDirectory:(NSString*)outputDir inTargetBuildContext:(PBXTargetBuildContext*)context
{
    // compute input path (for variable substitution)
    input = [context expandedValueForString:input];
    
    // The output file goes in the derived files dir.
    NSString* generatedOutputDir = [context expandedValueForString:@"$(DERIVED_FILE_DIR)"];
    NSString* outputBase = [generatedOutputDir stringByAppendingPathComponent:[[input lastPathComponent] stringByDeletingPathExtension]];
    NSString* sourceOutput = [outputBase stringByAppendingPathExtension:@"m"];
    NSString* headerOutput = [outputBase stringByAppendingPathExtension:@"h"];
    
    // create dependency nodes
    XCDependencyNode* outputSourceNode = [context dependencyNodeForName:sourceOutput createIfNeeded:YES];
    XCDependencyNode* outputHeaderNode = [context dependencyNodeForName:headerOutput createIfNeeded:YES];

    XCDependencyNode* inputNode = [context dependencyNodeForName:input createIfNeeded:YES];

    BOOL slice2cpp;
    // create slice2objc command
    XCDependencyCommand* dep = [context
                                createCommandWithRuleInfo:[NSArray arrayWithObjects:(slice2cpp ? @"slice2cpp" : @"slice2objc"),
                                                           [context naturalPathForPath:input],nil]
                                commandPath:[self getSliceTranslator:context isCpp:&slice2cpp]
                                arguments:nil
                                forNode:outputHeaderNode];
    [dep addOutputNode:outputSourceNode];
    [dep setToolSpecification:self]; // So Xcode knows how to parse the output, etc.
    [dep addArgumentsFromArray:[self commandLineForAutogeneratedOptionsInTargetBuildContext:context]];
    [dep addArgumentsFromArray:[[context expandedValueForString:@"$(build_file_compiler_flags)"] arrayByParsingAsStringList]];
    [dep addArgument:[NSString stringWithFormat:@"--output-dir=%@", generatedOutputDir]];
    [dep addArgument:input];
    [dep setPhaseNumber:3]; // This is the phase that the yacc plugin uses.
    [dep addEnvironmentValue:[self getSliceSharedLibrary:context] forKey:@"DYLD_LIBRARY_PATH"];
    
    // Create dependency rules. The source and the header depend on the
    // input file.
    [outputSourceNode addDependedNode:inputNode];
    [outputHeaderNode addDependedNode:inputNode];
    
    // Add the source & headder output to the generated source files.
    [context addPath:sourceOutput toFilePathListWithIdentifier:@"GeneratedSourceFiles"];
    [context addPath:headerOutput toFilePathListWithIdentifier:@"GeneratedSourceFiles"];

    // The yacc plugin does this, not sure why.
    [context setStringValue:input forDynamicSetting:@"source_file_path"];
    [context setStringValue:[[input lastPathComponent] stringByDeletingPathExtension] forDynamicSetting:@"output_file_base"];
    [context setStringValue:sourceOutput forDynamicSetting:@"intermediate_file_path"];
    [context setStringValue:@"m" forDynamicSetting:@"output_file_extension"];
    [context setStringValue:sourceOutput forDynamicSetting:@"output_file_path"];
    [context setStringValue:headerOutput forDynamicSetting:@"output_header_path"];

    // This causes importedFilesForPath to be called (dependency management
    // between slice files).
	[inputNode setScansFileContentsForIncludes:YES];

    // The output of the plugin is a single source node.
    return [NSArray arrayWithObject:outputSourceNode];
}

- (NSArray*)importedFilesForPath:(NSString*)path ensureFilesExist:(BOOL)ensure inTargetBuildContext:(PBXTargetBuildContext*)context
{
   	XCDependencyNode* inputNode = [context dependencyNodeForName:path createIfNeeded:YES];
    NSMutableArray* imported = [NSMutableArray arrayWithCapacity:10];
    NSEnumerator *e = [[self dependenciesForSliceFile:path context:context] objectEnumerator];
	NSString *filename;
	while (filename = [e nextObject])
    {
        NSString *filepath = [context absolutePathForPath:filename];
		XCDependencyNode *node = [context dependencyNodeForName:filepath createIfNeeded:YES];
		[node setDontCareIfExists:YES];
		[inputNode addIncludedNode:node];
		[imported addObject:filename];
    }
    
    return imported;
}

/*
- (XCPropertyDomainSpecification*) specificationToShowInUserInterface
{
	XCPropertyDomainSpecification* spec = [[XCPropertyDomainSpecification specificationRegistry] objectForKey:@"com.zeroc.compilers.slice"];
	return (XCPropertyDomainSpecification*)[spec loadedSpecification];
}
 */

@end