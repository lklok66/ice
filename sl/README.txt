Please see the file INSTALL.txt for installation instructions.

Threading
---------

Ice for Silverlight supports making invocations from both the UI
thread and non-UI threads. However, only asynchonous invocations can be
made from the UI thread while non-UI threads allow both synchronous
and asynchronous invocations.


Asynchronous Message Invocation (AMI)
-------------------------------------

AMI is implemented differently in Ice for Silverlight than it is in
Ice for C#. Specifically, the means by which you define the callbacks
that are called once the AMI method either succeeds or fails is 
different.

In Ice for C# it is necessary for the application to extend an AMI
callback class generated by the Slice-to-C# translator and implement
the abstract ice_response() and ice_exception() methods in the 
derived class. A instance of this class is then passed to the async
call on the proxy.

For example consider the following Slice definitions:

    module Foo
    {
        interface Bar
        {
            void method(int param1, out string param2);
        };
    };

The AMI callback class generated for the operation "method" would be
named Foo.AMI_Bar_method and the user would have to implement a 
callback class similar to the following:

    class AMI_Bar_methodI : Foo.AMI_Bar_method
    {
        public override void ice_response(string param2)
        {
            // Called on success
            ...
        }

        public override void ice_exception(Ice.Exception ex)
        {
            // Called on failure
            ...
        }
    }

The method invocation would then look like the following:

    public void someFunction()
    {
        ...

        Foo.BarPrx proxy = ... // Obtain proxy by regular means
        proxy.method_async(new AMI_Bar_methodI(), 0);

        ...
    }

Ice for Silverlight uses C# delegates instead of a callback class to
notify the program about the completion of an operation. The caller
must supply two delegate functions, one for the response callback and
one for the exception callback. The signatures for these methods are
the same as those for the ice_response() and ice_exception() methods
in Ice for C#.

Using the same Slice definitions as the example above, an Ice for
Silverlight program could invoke the AMI operation as follows:

    public void methodResponse(string param2)
    {
        // Called on success
        ...
    }

    public void methodException(Ice.Exception ex)
    {
        // Called on failure
        ...
    }

    public void someFunction()
    {
        ...

        Foo.BarPrx proxy = ... // Obtain proxy by regular means
        proxy.method_async(methodResponse, methodException, 0);

        ...
    }


User Exceptions and Object-by-Value
-----------------------------------

Ice for .NET uses reflection during the unmarshaling of user
exceptions and objects by value. Since Silverlight does not support
retrieving the list of assemblies loaded with the application, it is
necessary to explicitly configure the list of assemblies where the
user exception or object by value types are located.

This is done using the Ice.FactoryAssemblies property, which is set
to a list of qualified assembly names separated by whitespace. For
example:

  Ice.FactoryAssemblies=UserAssembly1,version=1.0.0 UserAssembly2,version=1.0.0.0

If you don't set this property, your client will throw
Ice.UnmarshalOutOfBoundsException or Ice.NoObjectFactoryException if it
receives an unknown user exception or object by value respectively.
