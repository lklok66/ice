Please see the file INSTALL.txt for installation instructions.


Asynchronous Message Invocation (AMI)
-------------------------------------

AMI is implemented differently in Ice for Silverlight than it is in
Ice for C#. Specifically, the means by which you define the callbacks
that are called once the AMI method either succeeds or fails is 
different.

In Ice for C# it is necessary for the application to extend an AMI
callback class generated by the Slice-to-C# translator and implement
the abstract ice_response() and ice_exception() methods in the 
derived class. A instance of this class is then passed to the async
call on the proxy.

For example consider the following Slice definitions:

    module Foo
    {
        interface Bar
        {
            void method(int param1, out string param2);
        };
    };

The AMI callback class generated for the operation "method" would be
named Foo.AMI_Bar_method and the user would have to implement a 
callback class similar to the following:

    class AMI_Bar_methodI : Foo.AMI_Bar_method
    {
        public override void ice_response(string param2)
        {
            // Called on success
            ...
        }

        public override void ice_exception(Ice.Exception ex)
        {
            // Called on failure
            ...
        }
    }

The method invocation would then look like the following:

    public void someFunction()
    {
        ...

        Foo.BarPrx proxy = ... // Obtain proxy by regular means
        proxy.method_async(new AMI_Bar_methodI(), 0);

        ...
    }

Ice for Silverlight uses C# delegates instead of a callback class to
notify the program about the completion of an operation. The caller
must supply two delegate functions, one for the response callback and
one for the exception callback. The signatures for these methods are
the same as those for the ice_response() and ice_exception() methods
in Ice for C#.

Using the same Slice definitions as the example above, an Ice for
Silverlight program could invoke the AMI operation as follows:

    public void methodResponse(string param2)
    {
        // Called on success
        ...
    }

    public void methodException(Ice.Exception ex)
    {
        // Called on failure
        ...
    }

    public void someFunction()
    {
        ...

        Foo.BarPrx proxy = ... // Obtain proxy by regular means
        proxy.method_async(methodResponse, methodException, 0);

        ...
    }


User Exceptions and Object-by-Value
-----------------------------------

Ice for .NET uses reflection during the unmarshaling of user
exceptions and objects by value. Unfortunately, Silverlight does not
support the method AppDomain.CurrentDomain.GetAssemblies(), which
means that user exceptions and objects received by value must reside
in the same assembly as the Ice for Silverlight run time. If Ice
cannot find the type, it raises an Ice.UnmarshalOutOfBoundsException.

The easiest way to ensure that Ice can find the relevant types is to
merge the IceSL.dll assembly with your application code assembly,
which you can do using the ILMerge tool provided by Microsoft. Please
see the link below for more information:

  http://research.microsoft.com/~mbarnett/ILMerge.aspx
