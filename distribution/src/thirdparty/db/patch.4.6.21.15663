*** dbinc_auto/env_ext.h.orig	2007-05-22 20:35:38.000000000 +0300
--- dbinc_auto/env_ext.h	2009-01-09 12:47:33.115600000 +0200
***************
*** 16,21 ****
--- 16,22 ----
  int __config_split __P((char *, char *[]));
  int __env_failchk_pp __P((DB_ENV *, u_int32_t));
  int __env_thread_init __P((DB_ENV *, int));
+ void __env_thread_destroy __P((DB_ENV *));
  int __env_set_state __P((DB_ENV *, DB_THREAD_INFO **, DB_THREAD_STATE));
  char *__env_thread_id_string __P((DB_ENV *, pid_t, db_threadid_t, char *));
  int __db_file_extend __P((DB_ENV *, DB_FH *, size_t));
*** dbinc_auto/int_def.in.orig	2007-06-01 18:40:08.000000000 +0300
--- dbinc_auto/int_def.in	2009-01-09 12:48:55.814515200 +0200
***************
*** 645,650 ****
--- 645,651 ----
  #define	__config_split __config_split@DB_VERSION_UNIQUE_NAME@
  #define	__env_failchk_pp __env_failchk_pp@DB_VERSION_UNIQUE_NAME@
  #define	__env_thread_init __env_thread_init@DB_VERSION_UNIQUE_NAME@
+ #define	__env_thread_destroy __env_thread_destroy@DB_VERSION_UNIQUE_NAME@
  #define	__env_set_state __env_set_state@DB_VERSION_UNIQUE_NAME@
  #define	__env_thread_id_string __env_thread_id_string@DB_VERSION_UNIQUE_NAME@
  #define	__db_file_extend __db_file_extend@DB_VERSION_UNIQUE_NAME@
*** env/env_failchk.c.orig	2007-06-06 17:34:42.000000000 +0300
--- env/env_failchk.c	2009-01-09 12:58:07.587926400 +0200
***************
*** 134,139 ****
--- 134,177 ----
  }
  
  /*
+  * __env_thread_destroy --
+  *	Destroy the thread control block table.
+  *
+  * PUBLIC: void __env_thread_destroy __P((DB_ENV *));
+  */
+ void
+ __env_thread_destroy(dbenv)
+ 	DB_ENV *dbenv;
+ {
+ 	DB_HASHTAB *htab;
+ 	DB_THREAD_INFO *ip, *np;
+ 	REGINFO *infop;
+ 	REGENV *renv;
+ 	THREAD_INFO *thread;
+ 	u_int32_t i;
+ 
+ 	infop = dbenv->reginfo;
+ 	renv = infop->primary;
+ 	if (renv->thread_off == INVALID_ROFF) 
+ 		return;
+ 
+ 	thread = R_ADDR(infop, renv->thread_off);
+ 	if ((htab = dbenv->thr_hashtab) != NULL)
+ 		for (i = 0; i < dbenv->thr_nbucket; i++) {
+ 			ip = SH_TAILQ_FIRST(&htab[i], __db_thread_info);
+ 			for (; ip != NULL; ip = np) {
+ 				np = SH_TAILQ_NEXT(ip,
+ 					dbth_links, __db_thread_info);
+ 				__env_alloc_free(infop, ip);
+ 			}
+ 		}
+ 
+ 	__env_alloc_free(infop, htab);
+ 	__env_alloc_free(infop, thread);
+ 	return;
+ }
+ 
+ /*
   * __env_in_api --
   *	Look for threads which died in the api and complain.
   */
*** env/env_open.c.orig	2007-06-08 19:34:56.000000000 +0300
--- env/env_open.c	2009-01-09 13:00:09.683491200 +0200
***************
*** 934,939 ****
--- 934,942 ----
  	    (t_ret = __mutex_env_refresh(dbenv)) != 0 && ret == 0)
  		ret = t_ret;
  #endif
+ 	/* Free memory for thread tracking. */
+ 	if (F_ISSET(dbenv, DB_ENV_PRIVATE))
+ 		__env_thread_destroy(dbenv);
  
  	if (dbenv->reginfo != NULL && (t_ret = __env_detach(
  	    dbenv, F_ISSET(dbenv, DB_ENV_PRIVATE) ? 1 : 0)) != 0 && ret == 0) {
*** lock/lock_region.c.orig	2007-05-17 17:15:44.000000000 +0300
--- lock/lock_region.c	2009-01-09 13:03:59.063323200 +0200
***************
*** 342,347 ****
--- 342,355 ----
  		/* Discard the locker hash table. */
  		__env_alloc_free(reginfo, R_ADDR(reginfo, lr->locker_off));
  
+ 		/* Discard the object hash stat table. */
+ 		__env_alloc_free(reginfo, R_ADDR(reginfo, lr->stat_off));
+ 
+ #ifdef HAVE_FINE_GRAINED_LOCK_MANAGER
+ 		/* Discard the object hash mutex table. */
+ 		__env_alloc_free(reginfo, R_ADDR(reginfo, lr->mtx_off));
+ #endif
+ 
  		/* Discard locks. */
  		while ((lp =
  		    SH_TAILQ_FIRST(&lr->free_locks, __db_lock)) != NULL) {
*** log/log.c.orig	2007-06-04 23:30:52.000000000 +0300
--- log/log.c	2009-01-09 13:08:28.220352000 +0200
***************
*** 772,777 ****
--- 772,778 ----
  	LOG *lp;
  	REGINFO *reginfo;
  	struct __fname *fnp;
+ 	struct __db_commit *commit;
  	struct __db_filestart *filestart;
  	int ret, t_ret;
  
***************
*** 841,846 ****
--- 842,855 ----
  			__env_alloc_free(reginfo, filestart);
  		}
  
+ 		/* Discard commit queue elements. */
+ 		while ((commit = SH_TAILQ_FIRST(&lp->free_commits,
+ 			__db_commit)) != NULL) {
+ 			SH_TAILQ_REMOVE(&lp->free_commits, commit, links,
+ 				__db_commit);
+ 			__env_alloc_free(reginfo, commit);
+ 		}
+ 
  		/* Discard replication bulk buffer. */
  		if (lp->bulk_buf != INVALID_ROFF) {
  			__env_alloc_free(reginfo,
